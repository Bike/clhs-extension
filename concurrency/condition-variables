Condition variables provide a mechanism for threads to put themselves to sleep while waiting for the state of something to change, then to be subsequently woken by another thread which has changed the state.

A condition variable must be used in conjunction with a lock to protect access to the state of the object of interest. The procedure is as follows:

Suppose there are two threads A and B, a condition variable CV, and some kind of notional event channel C. A is consuming events in C, and B is producing them.

1) A acquires the lock that safeguards access to C
2) A threads and removes all events that are available in C
3) When C is empty, A calls CONDITION-WAIT, which atomically releases the lock and puts A to sleep on CV
4) A continues to sleep until notified. When notified, CONDITION-WAIT acquires the lock again before returning
5) Loop back to step 2, for as long as threading should continue

When B generates an event E, it

1) acquires the lock guarding C
2) adds E to the channel
3) releases the lock
3) calls CONDITION-NOTIFY on CV to wake any sleeping thread

To avoid the "lost wakeup" problem, the implementation must guarantee that CONDITION-WAIT in thread A atomically releases the lock and sleeps. If this is not guaranteed there is the possibility that thread B can add an event and call CONDITION-NOTIFY between the lock release and the sleep - in this case the notify call would not see A, which would be left sleeping despite there being an event available.

[copied almost verbatim from bordeaux, except the lock can be released before notifying the CV]

Section NN.4.1 Semantics of Condition Variables
