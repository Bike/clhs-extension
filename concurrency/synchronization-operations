"Acquire" (or "acquisition") and "release" synchronization operations relate to some value, such as a lock, or to some place. Acquire operations are reads, and release operations are writes. If an acquire operation reads the value written by some release operation, that release operation may synchronize with that acquire operation, and so anything that happens before the release happens before the acquisition as well. (A more formal definition is given in NN.5.1.3.)

Acquisitions and releases impose constraints on evaluation order that can be used to implement mutual exclusion, among other things. Consider the following example. Say lock is a place that has value 1 initially, and data has value 0 initially. Now say there are two threads executing; one evaluates (setf data 347 lock 0), and another evaluates (progn (loop while (plusp lock)) data). If lock is merely atomic, there is no guarantee that the (setf data 347) happens-before the loop exiting, and so the second form may return 0, even though (setf data 347) is sequenced-before the (setf lock 0) that produced the value read by the loop. But if lock is released by the first thread and acquired by the second, (setf lock 0) must happen before the second thread's evaluation of lock that returned 0, and as such the (setf data 347) happens before the end of the loop as well; so the second thread returns 347, even if data is not atomic at all.

While acquire and release operations do synchronize, there is not necessarily a total order of acquisition and release operations on distinct objects or places. Sequentially consistent operations are acquire and/or release operations that additionally impose an order of this kind.
